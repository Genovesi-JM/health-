from __future__ import annotations
"""
Risk Engine v1 - Rule-Based Risk Assessment

Sectors supported:
- Mining: ESG compliance, tailings dam monitoring, terrain stability
- Infrastructure: Structural health, timeline delays, budget overruns
- Construction: Safety violations, progress tracking, quality control
- Agriculture: Crop health, irrigation efficiency, pest detection
- Demining: Clearance progress, safety protocols, terrain risk

Output:
- risk_score: 0-100 (0=lowest risk, 100=highest)
- risk_level: low/medium/high/critical
- triggers: List of triggered rules
- alerts: Generated alerts for dashboard
- recommendations: Suggested actions
"""
import logging
from datetime import datetime
from typing import Optional, List, Dict, Any
from enum import Enum
from dataclasses import dataclass, field
from pydantic import BaseModel

logger = logging.getLogger(__name__)


# ============ ENUMS & TYPES ============

class RiskLevel(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertSeverity(str, Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class SectorType(str, Enum):
    MINING = "mining"
    INFRASTRUCTURE = "infrastructure"
    CONSTRUCTION = "construction"
    AGRO = "agro"
    DEMINING = "demining"
    SOLAR = "solar"


# ============ DATA CLASSES ============

@dataclass
class RuleResult:
    """Result from a single rule evaluation."""
    rule_id: str
    rule_name: str
    triggered: bool
    score_contribution: float  # Points added to risk score
    message: str
    severity: AlertSeverity
    data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class RiskAlert:
    """Alert generated by risk assessment."""
    id: str
    title: str
    message: str
    severity: AlertSeverity
    sector: SectorType
    source: str
    metric_name: Optional[str] = None
    metric_value: Optional[float] = None
    threshold: Optional[float] = None
    recommendation: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class RiskAssessmentResult:
    """Complete risk assessment output."""
    assessment_id: str
    site_id: str
    sector: SectorType
    risk_score: float  # 0-100
    risk_level: RiskLevel
    triggered_rules: List[RuleResult]
    alerts: List[RiskAlert]
    recommendations: List[str]
    input_data: Dict[str, Any]
    assessed_at: datetime = field(default_factory=datetime.utcnow)


# ============ RULE DEFINITIONS ============

class RuleEngine:
    """Base class for sector-specific rule engines."""
    
    def __init__(self, sector: SectorType):
        self.sector = sector
        self.rules = []
    
    def evaluate(self, data: Dict[str, Any]) -> List[RuleResult]:
        """Evaluate all rules against input data."""
        results = []
        for rule in self.rules:
            try:
                result = rule(data)
                results.append(result)
            except Exception as e:
                logger.warning(f"Rule evaluation error: {e}")
        return results


class MiningRuleEngine(RuleEngine):
    """Risk rules for mining operations."""
    
    def __init__(self):
        super().__init__(SectorType.MINING)
        self.rules = [
            self.rule_tailings_dam_level,
            self.rule_terrain_displacement,
            self.rule_esg_compliance,
            self.rule_dust_concentration,
            self.rule_water_quality,
            self.rule_extraction_efficiency,
        ]
    
    def rule_tailings_dam_level(self, data: Dict) -> RuleResult:
        """Check tailings dam fill level."""
        level = data.get("tailings_level_pct", 0)
        
        if level >= 90:
            return RuleResult(
                rule_id="mining_tailings_90",
                rule_name="Tailings Dam Critical",
                triggered=True,
                score_contribution=40,
                message=f"Tailings dam at {level}% capacity - CRITICAL",
                severity=AlertSeverity.CRITICAL,
                data={"level": level, "threshold": 90}
            )
        elif level >= 80:
            return RuleResult(
                rule_id="mining_tailings_80",
                rule_name="Tailings Dam Warning",
                triggered=True,
                score_contribution=20,
                message=f"Tailings dam at {level}% capacity",
                severity=AlertSeverity.WARNING,
                data={"level": level, "threshold": 80}
            )
        
        return RuleResult(
            rule_id="mining_tailings_ok",
            rule_name="Tailings Dam Level",
            triggered=False,
            score_contribution=0,
            message=f"Tailings dam at {level}% - OK",
            severity=AlertSeverity.INFO,
            data={"level": level}
        )
    
    def rule_terrain_displacement(self, data: Dict) -> RuleResult:
        """Check terrain/slope displacement from InSAR/LiDAR."""
        displacement_mm = data.get("terrain_displacement_mm", 0)
        
        if displacement_mm >= 50:
            return RuleResult(
                rule_id="mining_displacement_50",
                rule_name="Terrain Displacement Critical",
                triggered=True,
                score_contribution=35,
                message=f"Terrain displacement {displacement_mm}mm detected - evacuation review needed",
                severity=AlertSeverity.CRITICAL,
                data={"displacement": displacement_mm, "threshold": 50}
            )
        elif displacement_mm >= 20:
            return RuleResult(
                rule_id="mining_displacement_20",
                rule_name="Terrain Displacement Warning",
                triggered=True,
                score_contribution=15,
                message=f"Terrain displacement {displacement_mm}mm - monitoring increased",
                severity=AlertSeverity.WARNING,
                data={"displacement": displacement_mm, "threshold": 20}
            )
        
        return RuleResult(
            rule_id="mining_displacement_ok",
            rule_name="Terrain Stability",
            triggered=False,
            score_contribution=0,
            message="Terrain stable",
            severity=AlertSeverity.INFO,
            data={"displacement": displacement_mm}
        )
    
    def rule_esg_compliance(self, data: Dict) -> RuleResult:
        """Check ESG compliance score."""
        score = data.get("esg_score", 100)
        
        if score < 60:
            return RuleResult(
                rule_id="mining_esg_low",
                rule_name="ESG Compliance Low",
                triggered=True,
                score_contribution=25,
                message=f"ESG compliance score {score}% - regulatory risk",
                severity=AlertSeverity.ERROR,
                data={"score": score, "threshold": 60}
            )
        elif score < 75:
            return RuleResult(
                rule_id="mining_esg_medium",
                rule_name="ESG Compliance Warning",
                triggered=True,
                score_contribution=10,
                message=f"ESG compliance score {score}% - improvement needed",
                severity=AlertSeverity.WARNING,
                data={"score": score, "threshold": 75}
            )
        
        return RuleResult(
            rule_id="mining_esg_ok",
            rule_name="ESG Compliance",
            triggered=False,
            score_contribution=0,
            message=f"ESG score {score}%",
            severity=AlertSeverity.INFO,
            data={"score": score}
        )
    
    def rule_dust_concentration(self, data: Dict) -> RuleResult:
        """Check dust/particulate concentration."""
        dust_ppm = data.get("dust_concentration_ppm", 0)
        
        if dust_ppm >= 100:
            return RuleResult(
                rule_id="mining_dust_high",
                rule_name="Dust Level Critical",
                triggered=True,
                score_contribution=20,
                message=f"Dust concentration {dust_ppm} PPM - health hazard",
                severity=AlertSeverity.ERROR,
                data={"dust": dust_ppm, "threshold": 100}
            )
        
        return RuleResult(
            rule_id="mining_dust_ok",
            rule_name="Dust Level",
            triggered=False,
            score_contribution=0,
            message=f"Dust level {dust_ppm} PPM",
            severity=AlertSeverity.INFO,
            data={"dust": dust_ppm}
        )
    
    def rule_water_quality(self, data: Dict) -> RuleResult:
        """Check water quality index."""
        wqi = data.get("water_quality_index", 100)
        
        if wqi < 50:
            return RuleResult(
                rule_id="mining_water_poor",
                rule_name="Water Quality Poor",
                triggered=True,
                score_contribution=20,
                message=f"Water quality index {wqi} - contamination risk",
                severity=AlertSeverity.ERROR,
                data={"wqi": wqi, "threshold": 50}
            )
        
        return RuleResult(
            rule_id="mining_water_ok",
            rule_name="Water Quality",
            triggered=False,
            score_contribution=0,
            message=f"Water quality index {wqi}",
            severity=AlertSeverity.INFO,
            data={"wqi": wqi}
        )
    
    def rule_extraction_efficiency(self, data: Dict) -> RuleResult:
        """Check extraction efficiency."""
        efficiency = data.get("extraction_efficiency_pct", 100)
        
        if efficiency < 70:
            return RuleResult(
                rule_id="mining_efficiency_low",
                rule_name="Extraction Efficiency Low",
                triggered=True,
                score_contribution=10,
                message=f"Extraction efficiency {efficiency}% - below target",
                severity=AlertSeverity.WARNING,
                data={"efficiency": efficiency, "threshold": 70}
            )
        
        return RuleResult(
            rule_id="mining_efficiency_ok",
            rule_name="Extraction Efficiency",
            triggered=False,
            score_contribution=0,
            message=f"Efficiency {efficiency}%",
            severity=AlertSeverity.INFO,
            data={"efficiency": efficiency}
        )


class InfrastructureRuleEngine(RuleEngine):
    """Risk rules for infrastructure monitoring."""
    
    def __init__(self):
        super().__init__(SectorType.INFRASTRUCTURE)
        self.rules = [
            self.rule_structural_health,
            self.rule_timeline_delay,
            self.rule_budget_overrun,
            self.rule_safety_incidents,
            self.rule_material_quality,
        ]
    
    def rule_structural_health(self, data: Dict) -> RuleResult:
        """Check structural health index from sensors/inspections."""
        shi = data.get("structural_health_index", 100)
        
        if shi < 60:
            return RuleResult(
                rule_id="infra_structural_critical",
                rule_name="Structural Health Critical",
                triggered=True,
                score_contribution=40,
                message=f"Structural health index {shi} - immediate inspection required",
                severity=AlertSeverity.CRITICAL,
                data={"shi": shi, "threshold": 60}
            )
        elif shi < 80:
            return RuleResult(
                rule_id="infra_structural_warning",
                rule_name="Structural Health Warning",
                triggered=True,
                score_contribution=20,
                message=f"Structural health index {shi} - maintenance recommended",
                severity=AlertSeverity.WARNING,
                data={"shi": shi, "threshold": 80}
            )
        
        return RuleResult(
            rule_id="infra_structural_ok",
            rule_name="Structural Health",
            triggered=False,
            score_contribution=0,
            message=f"Structural health index {shi}",
            severity=AlertSeverity.INFO,
            data={"shi": shi}
        )
    
    def rule_timeline_delay(self, data: Dict) -> RuleResult:
        """Check project timeline delay."""
        delay_days = data.get("timeline_delay_days", 0)
        
        if delay_days >= 30:
            return RuleResult(
                rule_id="infra_delay_major",
                rule_name="Major Timeline Delay",
                triggered=True,
                score_contribution=25,
                message=f"Project {delay_days} days behind schedule",
                severity=AlertSeverity.ERROR,
                data={"delay": delay_days, "threshold": 30}
            )
        elif delay_days >= 7:
            return RuleResult(
                rule_id="infra_delay_minor",
                rule_name="Timeline Delay",
                triggered=True,
                score_contribution=10,
                message=f"Project {delay_days} days behind schedule",
                severity=AlertSeverity.WARNING,
                data={"delay": delay_days, "threshold": 7}
            )
        
        return RuleResult(
            rule_id="infra_timeline_ok",
            rule_name="Timeline Status",
            triggered=False,
            score_contribution=0,
            message="Project on schedule",
            severity=AlertSeverity.INFO,
            data={"delay": delay_days}
        )
    
    def rule_budget_overrun(self, data: Dict) -> RuleResult:
        """Check budget overrun percentage."""
        overrun_pct = data.get("budget_overrun_pct", 0)
        
        if overrun_pct >= 20:
            return RuleResult(
                rule_id="infra_budget_critical",
                rule_name="Budget Overrun Critical",
                triggered=True,
                score_contribution=25,
                message=f"Budget overrun {overrun_pct}% - cost review needed",
                severity=AlertSeverity.ERROR,
                data={"overrun": overrun_pct, "threshold": 20}
            )
        elif overrun_pct >= 10:
            return RuleResult(
                rule_id="infra_budget_warning",
                rule_name="Budget Overrun",
                triggered=True,
                score_contribution=10,
                message=f"Budget overrun {overrun_pct}%",
                severity=AlertSeverity.WARNING,
                data={"overrun": overrun_pct, "threshold": 10}
            )
        
        return RuleResult(
            rule_id="infra_budget_ok",
            rule_name="Budget Status",
            triggered=False,
            score_contribution=0,
            message="Budget on track",
            severity=AlertSeverity.INFO,
            data={"overrun": overrun_pct}
        )
    
    def rule_safety_incidents(self, data: Dict) -> RuleResult:
        """Check safety incident count."""
        incidents = data.get("safety_incidents_30d", 0)
        
        if incidents >= 3:
            return RuleResult(
                rule_id="infra_safety_high",
                rule_name="High Safety Incidents",
                triggered=True,
                score_contribution=30,
                message=f"{incidents} safety incidents in 30 days - safety review required",
                severity=AlertSeverity.ERROR,
                data={"incidents": incidents, "threshold": 3}
            )
        elif incidents >= 1:
            return RuleResult(
                rule_id="infra_safety_warning",
                rule_name="Safety Incident",
                triggered=True,
                score_contribution=15,
                message=f"{incidents} safety incident(s) in 30 days",
                severity=AlertSeverity.WARNING,
                data={"incidents": incidents, "threshold": 1}
            )
        
        return RuleResult(
            rule_id="infra_safety_ok",
            rule_name="Safety Record",
            triggered=False,
            score_contribution=0,
            message="No safety incidents",
            severity=AlertSeverity.INFO,
            data={"incidents": incidents}
        )
    
    def rule_material_quality(self, data: Dict) -> RuleResult:
        """Check material quality test results."""
        pass_rate = data.get("material_quality_pass_rate", 100)
        
        if pass_rate < 90:
            return RuleResult(
                rule_id="infra_material_fail",
                rule_name="Material Quality Issues",
                triggered=True,
                score_contribution=20,
                message=f"Material quality pass rate {pass_rate}%",
                severity=AlertSeverity.WARNING,
                data={"pass_rate": pass_rate, "threshold": 90}
            )
        
        return RuleResult(
            rule_id="infra_material_ok",
            rule_name="Material Quality",
            triggered=False,
            score_contribution=0,
            message=f"Material quality {pass_rate}%",
            severity=AlertSeverity.INFO,
            data={"pass_rate": pass_rate}
        )


# ============ RISK ASSESSMENT SERVICE ============

class RiskEngine:
    """
    Main risk assessment engine.
    
    Evaluates sector-specific rules and generates risk scores and alerts.
    """
    
    SECTOR_ENGINES = {
        SectorType.MINING: MiningRuleEngine,
        SectorType.INFRASTRUCTURE: InfrastructureRuleEngine,
        # FUTURE: Add Agro, Construction, Solar, Demining sector engines
    }
    
    RISK_THRESHOLDS = {
        RiskLevel.LOW: 25,
        RiskLevel.MEDIUM: 50,
        RiskLevel.HIGH: 75,
        RiskLevel.CRITICAL: 100,
    }
    
    def __init__(self):
        self.engines = {
            sector: engine_class()
            for sector, engine_class in self.SECTOR_ENGINES.items()
        }
    
    def _score_to_level(self, score: float) -> RiskLevel:
        """Convert numeric score to risk level."""
        if score >= 75:
            return RiskLevel.CRITICAL
        elif score >= 50:
            return RiskLevel.HIGH
        elif score >= 25:
            return RiskLevel.MEDIUM
        return RiskLevel.LOW
    
    def _generate_recommendations(
        self,
        sector: SectorType,
        triggered_rules: List[RuleResult]
    ) -> List[str]:
        """Generate recommendations based on triggered rules."""
        recommendations = []
        
        for rule in triggered_rules:
            if rule.severity == AlertSeverity.CRITICAL:
                recommendations.append(f"URGENT: Address {rule.rule_name} immediately")
            elif rule.severity == AlertSeverity.ERROR:
                recommendations.append(f"Review {rule.rule_name} within 24 hours")
            elif rule.severity == AlertSeverity.WARNING:
                recommendations.append(f"Monitor {rule.rule_name}")
        
        # Add sector-specific recommendations
        if sector == SectorType.MINING:
            if any(r.rule_id.startswith("mining_tailings") and r.triggered for r in triggered_rules):
                recommendations.append("Schedule tailings capacity expansion review")
            if any(r.rule_id.startswith("mining_displacement") and r.triggered for r in triggered_rules):
                recommendations.append("Conduct geotechnical stability assessment")
        
        elif sector == SectorType.INFRASTRUCTURE:
            if any(r.rule_id.startswith("infra_delay") and r.triggered for r in triggered_rules):
                recommendations.append("Review critical path and resource allocation")
            if any(r.rule_id.startswith("infra_budget") and r.triggered for r in triggered_rules):
                recommendations.append("Conduct cost variance analysis")
        
        return recommendations[:5]  # Limit to top 5
    
    def _generate_alerts(
        self,
        site_id: str,
        sector: SectorType,
        triggered_rules: List[RuleResult]
    ) -> List[RiskAlert]:
        """Generate alerts from triggered rules."""
        import uuid
        alerts = []
        
        for rule in triggered_rules:
            alert = RiskAlert(
                id=str(uuid.uuid4()),
                title=rule.rule_name,
                message=rule.message,
                severity=rule.severity,
                sector=sector,
                source="risk_engine",
                metric_name=rule.rule_id,
                metric_value=rule.data.get("value"),
                threshold=rule.data.get("threshold"),
                recommendation=None,
            )
            alerts.append(alert)
        
        return alerts
    
    def assess(
        self,
        site_id: str,
        sector: SectorType,
        data: Dict[str, Any]
    ) -> RiskAssessmentResult:
        """
        Run risk assessment for a site.
        
        Args:
            site_id: Site identifier
            sector: Sector type
            data: Sensor/metric data for evaluation
        
        Returns:
            Complete risk assessment result
        """
        import uuid
        
        # Get sector engine
        engine = self.engines.get(sector)
        if not engine:
            # Default assessment for unsupported sectors
            return RiskAssessmentResult(
                assessment_id=str(uuid.uuid4()),
                site_id=site_id,
                sector=sector,
                risk_score=0,
                risk_level=RiskLevel.LOW,
                triggered_rules=[],
                alerts=[],
                recommendations=[f"Risk engine for {sector.value} not implemented yet"],
                input_data=data,
            )
        
        # Evaluate rules
        rule_results = engine.evaluate(data)
        triggered = [r for r in rule_results if r.triggered]
        
        # Calculate score (capped at 100)
        risk_score = min(100, sum(r.score_contribution for r in triggered))
        risk_level = self._score_to_level(risk_score)
        
        # Generate outputs
        alerts = self._generate_alerts(site_id, sector, triggered)
        recommendations = self._generate_recommendations(sector, triggered)
        
        return RiskAssessmentResult(
            assessment_id=str(uuid.uuid4()),
            site_id=site_id,
            sector=sector,
            risk_score=risk_score,
            risk_level=risk_level,
            triggered_rules=triggered,
            alerts=alerts,
            recommendations=recommendations,
            input_data=data,
        )


# Singleton instance
_risk_engine: Optional[RiskEngine] = None


def get_risk_engine() -> RiskEngine:
    """Get or create risk engine instance."""
    global _risk_engine
    if _risk_engine is None:
        _risk_engine = RiskEngine()
    return _risk_engine


# ============ PYDANTIC SCHEMAS FOR API ============

class RiskAssessmentRequest(BaseModel):
    """Request schema for risk assessment."""
    site_id: str
    sector: SectorType
    data: Dict[str, Any]


class RuleResultSchema(BaseModel):
    rule_id: str
    rule_name: str
    triggered: bool
    score_contribution: float
    message: str
    severity: str
    data: Dict[str, Any] = {}


class RiskAlertSchema(BaseModel):
    id: str
    title: str
    message: str
    severity: str
    sector: str
    source: str
    metric_name: Optional[str] = None
    metric_value: Optional[float] = None
    threshold: Optional[float] = None
    recommendation: Optional[str] = None
    created_at: datetime


class RiskAssessmentResponse(BaseModel):
    assessment_id: str
    site_id: str
    sector: str
    risk_score: float
    risk_level: str
    triggered_rules: List[RuleResultSchema]
    alerts: List[RiskAlertSchema]
    recommendations: List[str]
    assessed_at: datetime
